---
title: "Inflammation statistics"
author: "Bendegúz Áron Varga"
date: "`r Sys.Date()`"
output:
  rmdformats::downcute:
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
    highlight: tango
---
# Importing

```{r setup, warning = F, message = F}
knitr::opts_chunk$set(echo = TRUE)

setwd('D:/Helsinki drive/OneDrive - University of Helsinki/____Trophin lab research/Thesis/Thesis_stat')

# Have to check which is for the correl plot
library(GGally)
library(ggExtra)
library(psych)
library(lemon)
library(ggrepel)


# Data management 
library(knitr)
library(readxl)
library(openxlsx)

# Descriptive statistics
library(ggplot2)
library(PupillometryR)
library(dplyr)

# Inductive statistics
library(lme4)
library(lmerTest)
library(multcomp)
library(redres)

# Classification
library(randomForest)
library(randomForestExplainer)

coverage <- read_excel("results_inflammation_UPDATED.xlsx", sheet = "coverage")
# whole <- read_excel("results_inflammation.xlsx", sheet = "QUINT")

# Changing variable nature
for(i in 6:24) {
  coverage[, i] <- lapply(coverage[, i], as.numeric)
}

# Exclude groups for now
coverage <- coverage[coverage$Group %in% c('Control','Window','Window+CORT', 'Pos_Control'),]

# Taking care of level orders
coverage$Group <- factor(coverage$Group, levels = c('Control', 'Window', 'Window+CORT', 'Pos_Control'))
coverage$Bregma <- factor(coverage$Bregma, levels = c('-2.1mm', '-0.8mm', '0.8mm', '2.1mm'))
```


# QUINT macro

```{r compile_quint_big_regions, warning = F, message = F}
#------------GFAP---------------

# Set the base directory where your files are located
base_dir <- "D:/Microscopy/QUINT/C1_GFAP"
row <- 1
dataset <- data.frame(NA)

# Loop over the IDs
for (ID in 1:9) {
  # Construct the directory path for each ID
  dir_path <- file.path(base_dir, paste0("ID", ID), "Reports", paste0("GFAP_ID", ID, "_CustomRegions"))
  
  # Construct the file path for each Excel file
  file_path <- file.path(dir_path, paste0("GFAP_ID", ID, "_CustomRegions_All.csv"))
  
  # Read the Excel file
  dataloop <- read.table(file_path, sep = ";", dec = ".", header = T)
  
  if (nrow(dataloop) >= 10 && ncol(dataloop) >= 9) {
    dataset[row:(row+9), 1:9] <- dataloop[1:10, 1:9]
    row <- row + 10}
  
}

dataset$ID_easy <- rep(coverage[1:9, "ID_easy"][[1]], each = 10)
dataset$Group <- rep(coverage[1:9, "Group"][[1]], each = 10)
dataset$NA. <- ifelse(dataset$NA. == 'Hippo',
                      'Hippocampus',
                      dataset$NA.)
dataset$NA. <- ifelse(dataset$NA. == 'VentricularSystem',
                      'Ventricular_System',
                      dataset$NA.)
dataset$Load <- dataset$Load*100
GFAP_Customregions_Allslices <- dataset[,c(10,11,1:9)]

write.xlsx(GFAP_Customregions_Allslices, "D:/Helsinki drive/OneDrive - University of Helsinki/____Trophin lab research/Thesis/Thesis_stat/GFAP_CustomRegions_AllAnimalsAllSlices.xlsx")

#------------IBA---------------

# Set the base directory where your files are located
base_dir <- "D:/Microscopy/QUINT/C2_IBA"
row <- 1
dataset <- data.frame(NA)

# Loop over the IDs
for (ID in 1:9) {
  # Construct the directory path for each ID
  dir_path <- file.path(base_dir, paste0("ID", ID), "Reports", paste0("IBA_ID", ID, "_CustomRegions"))
  
  # Construct the file path for each Excel file
  file_path <- file.path(dir_path, paste0("IBA_ID", ID, "_CustomRegions_All.csv"))
  
  # Read the Excel file
  dataloop <- read.table(file_path, sep = ";", dec = ".", header = T)
  
  if (nrow(dataloop) >= 10 && ncol(dataloop) >= 9) {
    dataset[row:(row+9), 1:9] <- dataloop[1:10, 1:9]
    row <- row + 10}
  
}

dataset$ID_easy <- rep(coverage[1:9, "ID_easy"][[1]], each = 10)
dataset$Group <- rep(coverage[1:9, "Group"][[1]], each = 10)
dataset$NA. <- ifelse(dataset$NA. == 'Hippo',
                      'Hippocampus',
                      dataset$NA.)
dataset$NA. <- ifelse(dataset$NA. == 'VentricularSystem',
                      'Ventricular_System',
                      dataset$NA.)
dataset$Load <- dataset$Load*100
IBA_Customregions_Allslices <- dataset[,c(10,11,1:9)]


write.xlsx(IBA_Customregions_Allslices, "D:/Helsinki drive/OneDrive - University of Helsinki/____Trophin lab research/Thesis/Thesis_stat/IBA_CustomRegions_AllAnimalsAllSlices.xlsx")
```

```{r compile_quint_small_regions, warning = F, message = F}
#------------GFAP---------------

# Set the base directory where your files are located
base_dir <- "D:/Microscopy/QUINT/C1_GFAP"
row <- 1
dataset <- data.frame(NA)

# Loop over the IDs
for (ID in 1:9) {
  # Construct the directory path for each ID
  dir_path <- file.path(base_dir, paste0("ID", ID), "Reports", paste0("GFAP_ID", ID, "_RefAtlasRegions"))
  
  # Construct the file path for each Excel file
  file_path <- file.path(dir_path, paste0("GFAP_ID", ID, "_RefAtlasRegions.csv"))
  
  # Read the Excel file
  dataloop <- read.csv(file_path, quote  = "\"", sep = ";", dec = ".", header = T)
  
  if (nrow(dataloop) >= 1328) {
    dataset[row:(row+1327), 1:10] <- dataloop[1:1328, 1:10]
    row <- row + 1328}
  
}
dataset$Load <- dataset$Load*100
dataset$ID_easy <- rep(coverage[1:9, "ID_easy"][[1]], each = nrow(dataloop))
dataset$Group <- rep(coverage[1:9, "Group"][[1]], each = nrow(dataloop))
GFAP_RefAtlasRegions_Allslices <- dataset[,c(11,12,1:10)]

write.xlsx(GFAP_RefAtlasRegions_Allslices, "D:/Helsinki drive/OneDrive - University of Helsinki/____Trophin lab research/Thesis/Thesis_stat/GFAP_RefAtlasRegions_AllAnimalsAllSlices.xlsx")

#------------IBA---------------

# Set the base directory where your files are located
base_dir <- "D:/Microscopy/QUINT/C2_IBA"
row <- 1
dataset <- data.frame(NA)

# Loop over the IDs
for (ID in 1:9) {
  # Construct the directory path for each ID
  dir_path <- file.path(base_dir, paste0("ID", ID), "Reports", paste0("IBA_ID", ID, "_RefAtlasRegions"))
  
  # Construct the file path for each Excel file
  file_path <- file.path(dir_path, paste0("IBA_ID", ID, "_RefAtlasRegions.csv"))
  
  # Read the Excel file
  dataloop <- read.csv(file_path, quote  = "\"", sep = ";", dec = ".", header = T)
  
  if (nrow(dataloop) >= 1328) {
    dataset[row:(row+1327), 1:10] <- dataloop[1:1328, 1:10]
    row <- row + 1328}
  
}

dataset$Load <- dataset$Load*100
dataset$ID_easy <- rep(coverage[1:9, "ID_easy"][[1]], each = nrow(dataloop))
dataset$Group <- rep(coverage[1:9, "Group"][[1]], each = nrow(dataloop))
IBA_RefAtlasRegions_Allslices <- dataset[,c(11,12,1:10)]

write.xlsx(IBA_RefAtlasRegions_Allslices, "D:/Helsinki drive/OneDrive - University of Helsinki/____Trophin lab research/Thesis/Thesis_stat/IBA_RefAtlasRegions_AllAnimalsAllSlices.xlsx")
```

```{r QUINT_sliceLoadCalculation, warning = F, message = F}
#-----------GFAP----------

# Initialize dataframe to store results
results_df <- data.frame(ID = character(), Slice = character(), GFAP_SumObjectPixels = numeric(), GFAP_SumRegionPixels = numeric(), GFAP_Load = numeric(), stringsAsFactors = FALSE)

# Define IDs and their corresponding number of files
ids <- 1:9
num_files <- rep(4, 9)  # default 4 files for each ID
num_files[4] <- 2       # ID4 only has 2 files

# Iterate over each ID
for (id in ids) {
  # Determine file count for the current ID
  file_count <- num_files[id]
  
  # Initialize sums
  total_object_pixels = 0
  total_region_pixels = 0
  
  # Loop through each file for the current ID
  for (i in 1:file_count) {
    file_name <- sprintf("D:/Microscopy/QUINT/C1_GFAP/ID%d/Reports/GFAP_ID%d_RefAtlasRegions/GFAP_ID%d_RefAtlasRegions__s00%d.csv", id, id, id, i)
    # Read the file
    data <- read.csv(file_name, quote  = "\"", sep = ";", dec = ".", header = T)
    
    # Subset data where Region.pixels is non-zero
    subset_data <- subset(data, Region.pixels != 0)
    
    # Calculate sums
    total_object_pixels <- total_object_pixels + sum(subset_data$Object.pixels)
    total_region_pixels <- total_region_pixels + sum(subset_data$Region.pixels)
    # Calculate the ratio
  ratio <- total_object_pixels / total_region_pixels
  
  # Append results to the dataframe
  results_df <- rbind(results_df, data.frame(ID = paste("ID", id, sep=""), 
                                             Slice = paste("Slice", i, sep=""),
                                             GFAP_SumObjectPixels = total_object_pixels, 
                                             GFAP_SumRegionPixels = total_region_pixels, 
                                             GFAP_Load = ratio*100))
  }
}

coverage_nonPCs <- coverage[coverage$Group %in% c('Control', 'Window', 'Window+CORT'),]
coverage_nonPCs <- coverage_nonPCs[order(coverage_nonPCs$ID_easy),]
coverage_nonPCs <- cbind(coverage_nonPCs[c(1:14,17:36),], results_df[,3:5])

#-----------IBA----------

# Initialize dataframe to store results
results_df <- data.frame(ID = character(), Slice = character(), IBA_SumObjectPixels = numeric(), IBA_SumRegionPixels = numeric(), IBA_Load = numeric(), stringsAsFactors = FALSE)

# Define IDs and their corresponding number of files
ids <- 1:9
num_files <- rep(4, 9)  # default 4 files for each ID
num_files[4] <- 2       # ID4 only has 2 files

# Iterate over each ID
for (id in ids) {
  # Determine file count for the current ID
  file_count <- num_files[id]
  
  # Initialize sums
  total_object_pixels = 0
  total_region_pixels = 0
  
  # Loop through each file for the current ID
  for (i in 1:file_count) {
    file_name <- sprintf("D:/Microscopy/QUINT/C2_IBA/ID%d/Reports/IBA_ID%d_RefAtlasRegions/IBA_ID%d_RefAtlasRegions__s00%d.csv", id, id, id, i)
    # Read the file
    data <- read.csv(file_name, quote  = "\"", sep = ";", dec = ".", header = T)
    
    # Subset data where Region.pixels is non-zero
    subset_data <- subset(data, Region.pixels != 0)
    
    # Calculate sums
    total_object_pixels <- total_object_pixels + sum(subset_data$Object.pixels)
    total_region_pixels <- total_region_pixels + sum(subset_data$Region.pixels)
    # Calculate the ratio
    ratio <- total_object_pixels / total_region_pixels
    
    # Append results to the dataframe
    results_df <- rbind(results_df, data.frame(ID = paste("ID", id, sep=""), 
                                               Slice = paste("Slice", i, sep=""),
                                               IBA_SumObjectPixels = total_object_pixels, 
                                               IBA_SumRegionPixels = total_region_pixels, 
                                               IBA_Load = ratio*100))
  }
}

coverage_nonPCs <- cbind(coverage_nonPCs, results_df[,3:5])

```



# Custom-made functions

```{r myfunctions, warning = F, message = F}
themes <- theme(axis.title.y = element_text(size = rel(1.5), 
                                            angle = 90, 
                                            margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
                axis.title.x = element_text(size = rel(1.5), 
                                            angle = 0, 
                                            margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
                legend.title = element_text(size = rel(1.5), face = "bold"),
                legend.text = element_text(size = rel(1.5), angle = 0),
                axis.text  = element_text(size = rel(1.5), angle = 0),
                plot.title = element_text(color="darkgray",
                                          size=18,
                                          face="bold",
                                          margin = ggplot2::margin(t = 0, r = 100, b = 35, l = 100)),
                strip.text = element_text(size=rel(1.5),
                                          face="bold")) 

prince <- function(data, variable, yaxis) {
  ggplot(data, aes(y=variable,x=Group, color=Group))+
    geom_flat_violin(aes(fill = Group),
                     position = position_nudge(x = .2, y = 0),
                     adjust = 0.8,
                     trim = F,
                     alpha = .6,
                     colour = NA)+
    geom_boxplot(aes(x = Group, y = variable, fill = Group),
                 outlier.shape = NA, alpha = .6, width = .2, colour = "black")+
    geom_point(position = position_jitter(width = .05),
               size = 4,
               shape = 20)+
    ylab(yaxis)+
    theme_minimal() +
    theme(axis.title.y = element_text(size = rel(1.5), 
                                      angle = 90, 
                                      margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
          axis.title.x = element_blank(),
          legend.title = element_text(size = rel(1.2), face = "bold"),
          legend.text = element_text(size = rel(1.2), angle = 0),
          axis.text.x  = element_blank(),
          axis.text.y  = element_text(size = rel(1.5), angle = 0),
          plot.title = element_text(color="darkgray",
                                    size=18,
                                    face="bold",
                                    margin = ggplot2::margin(t = 0, r = 100, b = 35, l = 100)),
          strip.text.x = element_text(size = rel(1.5), angle = 0,
                                      face="bold")) + 
    scale_color_manual(values=c('#648FFF', '#785EF0', '#DC267F', '#FE6100', '#1EAD1E')) +
    scale_fill_manual(values=c('#648FFF', '#785EF0', '#DC267F', '#FE6100', '#1EAD1E'))+
    guides(fill = FALSE)}

box <- function(data, variable, yaxis) {
  ggplot(data, aes(y=variable,x=Group, color=Group))+
    geom_boxplot(aes(x = Group, y = variable, fill = Group),
                 outlier.shape = NA, alpha = .6, width = .6, colour = "black")+
    geom_point(position = position_jitter(width = .18),
               size = 6,
               shape = 20)+
    ylab(yaxis)+
    theme_minimal() +
    theme(axis.title.y = element_text(size = rel(1.7), 
                                      angle = 90, 
                                      margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
          axis.title.x = element_blank(),
          legend.title = element_text(size = rel(1.7), face = "bold"),
          legend.text = element_text(size = rel(1.7), angle = 0),
          axis.text.x  = element_blank(),
          axis.text.y  = element_text(size = rel(1.7), angle = 0),
          plot.title = element_text(color="darkgray",
                                    size=18,
                                    face="bold",
                                    margin = ggplot2::margin(t = 0, r = 100, b = 35, l = 100)),
          strip.text.x = element_text(size = rel(2.5), angle = 0,
                                      face="bold")) + 
    scale_color_manual(values=c('#648FFF', '#785EF0', '#DC267F', '#FE6100', '#1EAD1E')) +
    scale_fill_manual(values=c('#648FFF', '#785EF0', '#DC267F', '#FE6100', '#1EAD1E'))+
    guides(fill = FALSE)}

box_signo <- function(data, variable, yaxis) {
  ggplot(data, aes(y=variable,x=Group, color=Group))+
    geom_boxplot(aes(x = Group, y = variable, fill = Group),
                 outlier.shape = NA, alpha = .6, width = .4, colour = "black")+
    geom_point(position = position_jitter(width = .15),
               size = 6,
               shape = 20)+
    ylab(yaxis)+
    theme_minimal() +
    theme(axis.title.y = element_text(size = rel(1.7), 
                                      angle = 90, 
                                      margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
          axis.title.x = element_blank(),
          legend.title = element_text(size = rel(1.7), face = "bold"),
          legend.text = element_text(size = rel(1.7), angle = 0),
          axis.text.x  = element_blank(),
          axis.text.y  = element_text(size = rel(1.7), angle = 0),
          plot.title = element_text(color="darkgray",
                                    size=18,
                                    face="bold",
                                    margin = ggplot2::margin(t = 0, r = 100, b = 35, l = 100)),
          strip.text.x = element_text(size = rel(1.5), angle = 0,
                                      face="bold"))+
    guides(fill = FALSE)}

fittedplot <- function(data, mod) {
  a <- ggplot(data, aes(x = fitted(mod), y =  compute_redres(mod, type = "std_cond"), fill = 1))+
    geom_point()+
    stat_smooth(method="loess")+
    geom_hline(yintercept=0, col="red", linetype="dashed")+
    labs(x = "Fitted values", y = "Standardized residuals") +
    geom_point() +
    theme_minimal() +
    theme(legend.position = "none") +
    themes+
    xlim(min(fitted(mod))*0.9, max(fitted(mod))*1.1)
  
  df <- data.frame(y = residuals(mod))
  b <- ggplot(df, aes(sample = y)) +
    stat_qq() + stat_qq_line(lwd = 0.8)+
    theme_minimal() +
    themes + 
    labs(y = "Theoretical quantiles", x = "Sample quantiles")
  
  df1 <- data.frame(y = ranef(mod)[[1]])
  c <- ggplot(df1, aes(sample = pull(df1, 1))) +
    stat_qq() + stat_qq_line(lwd = 0.8)+
    theme_minimal() +
    themes + 
    labs(y = "Theoretical quantiles", x = "Sample quantiles")
  return(list(a,b,c))}

coverage_table <- data.frame(Response = c(),
                             Effect = c(),
                             Coefficient = c(),
                             Standard_error = c(),
                             T_value = c(),
                             p_value = c())
```

# Inflammation signal coverage - Fiji

## Coverage models

```{r coverage, warning = F, message = F, results='hide'}
# GFAP
mod_GFAP_cov <- lmer(GFAP_coverage~Group + (1|ID_easy),
                     data=coverage[!coverage$Group == 'Pos_Control',],
                     na.action=na.exclude)
summod_GFAP_cov <- summary(mod_GFAP_cov)

coverage_table[1:3, 'Response'] <- rep('GFAP coverage', 3)
coverage_table[1:3, 'Effect'] <- c('Control (intercept)', 'Window', 'Window+CORT')
coverage_table[1:3, 'Coefficient'] <- round(summod_GFAP_cov[["coefficients"]][1:3,1], 2)
coverage_table[1:3, 'Standard_error'] <- round(summod_GFAP_cov[["coefficients"]][1:3,2], 2)
coverage_table[1:3, 'T_value'] <- round(summod_GFAP_cov[["coefficients"]][1:3,4], 3)
coverage_table[1:3, 'p_value'] <- round(summod_GFAP_cov[["coefficients"]][1:3, 5], 4)

fittedplot(coverage[!coverage$Group == 'Pos_Control',], mod_GFAP_cov)

# IBA
mod_IBA_cov <- lmer(IBA_coverage~Group + (1|ID_easy),
                    data=coverage[!coverage$Group == 'Pos_Control',],
                    na.action=na.exclude)
summod_IBA_cov <- summary(mod_IBA_cov)

coverage_table[4:6, 'Response'] <- rep('IBA coverage', 3)
coverage_table[4:6, 'Effect'] <- c('Control (intercept)', 'Window', 'Window+CORT')
coverage_table[4:6, 'Coefficient'] <- round(summod_IBA_cov[["coefficients"]][1:3,1], 2)
coverage_table[4:6, 'Standard_error'] <- round(summod_IBA_cov[["coefficients"]][1:3,2], 2)
coverage_table[4:6, 'T_value'] <- round(summod_IBA_cov[["coefficients"]][1:3,4], 3)
coverage_table[4:6, 'p_value'] <- round(summod_IBA_cov[["coefficients"]][1:3, 5], 4)

fittedplot(coverage[!coverage$Group == 'Pos_Control',], mod_IBA_cov)
```
```{r coverage_model_kable, warning = F, message = F}
kable(coverage_table)
```

## Coverage contrasts

```{r coverage_contrasts, warning = F, message = F}
#GFAP
cont_GFAP_cover <- summary(glht(mod_GFAP_cov, linfct=mcp(Group="Tukey")))
kable(data.frame(Comparisons = c("Control-Window", "Control-Window+CORT", "Window-Window+CORT"),
                 Coefficient = round(cont_GFAP_cover[["test"]][["coefficients"]], 2),
                 Standard_error = round(cont_GFAP_cover[["test"]][["sigma"]], 2),
                 T_value = round(cont_GFAP_cover[["test"]][["tstat"]], 3),
                 p_value = round(cont_GFAP_cover[["test"]][["pvalues"]],4)))

# Little-prince plot with bregmas pooled - GFAP
prince(coverage, coverage$GFAP_coverage, 'GFAP coverage')+
  ylim(0,18)
prince(coverage, coverage$GFAP_coverage_MomentsThreshold, 'GFAP coverage (Moments threshold)')

# IBA
cont_IBA_cover <- summary(glht(mod_IBA_cov, linfct=mcp(Group="Tukey")))
kable(data.frame(Comparisons = c("Control-Window", "Control-Window+CORT", "Window-Window+CORT"),
                 Coefficient = round(cont_IBA_cover[["test"]][["coefficients"]], 2),
                 Standard_error = round(cont_IBA_cover[["test"]][["sigma"]], 2),
                 T_value = round(cont_IBA_cover[["test"]][["tstat"]], 3),
                 p_value = round(cont_IBA_cover[["test"]][["pvalues"]],4)))

# Little-prince plot with bregmas pooled - IBA
prince(coverage, coverage$IBA_coverage, 'IBA coverage') +
  ylim(0,50)

```

You can crop the PC from the bregma subplots, if you think it does not make sense to include them like this (because they correspond to different bregma planes than are analysed for the other experimental groups).

```{r Faceted_princes, warning = F, message = F, fig.width=16, fig.height=6}
# Little-prince plot with bregma faceting - GFAP
box(coverage, coverage$GFAP_coverage, 'GFAP coverage') +
  facet_wrap(~Bregma, dir="v",ncol=4, scales = "free_y")+
  ylim(0,18) 
box(coverage, coverage$GFAP_coverage_MomentsThreshold, 'GFAP coverage (Moments threshold)') +
  facet_wrap(~Bregma, dir="v",ncol=4, scales = "free_y")

# Little-prince plot with bregma faceting - IBA
box(coverage, coverage$IBA_coverage, 'IBA coverage') +
  facet_wrap(~Bregma, dir="v",ncol=4, scales = "free_y")+
  ylim(0,50)
```


## Correlation between IBA and GFAP coverage

```{r IBA-GFAP correlations, warning = F, message = F}
coverage$factor <- factor(1)
regr <-  ggplot(coverage,aes(x=IBA_coverage,y=GFAP_coverage, Group=factor))+
  stat_smooth(method="lm", col='black')+
  geom_point(size = 3, col='black')+
  ylab('GFAP coverage')+
  xlab('IBA coverage')+
  theme_minimal() +
  themes +
  theme(legend.position = "none")

ggMarginal(regr, groupColour = TRUE, groupFill = T)

corrcoverage <- cor.test(coverage$GFAP_coverage, coverage$IBA_coverage, method = 'spearman')

kable(data.frame('Correlation' = c('GFAP-IBA coverage'),
                 'Rho' = round(corrcoverage$estimate, 3),
                 'p_value' = round(corrcoverage$p.value, 4)))
```

# Correlation Fiji and QUINT

```{r Fiji-QUINT_GFAP correlations, warning = F, message = F}
#--------------GFAP------------------------
coverage_nonPCs$factor <- factor(1)
regr <-  ggplot(coverage_nonPCs,aes(x=GFAP_coverage,y=GFAP_Load, Group=factor))+
  stat_smooth(method="lm", col='black')+
  geom_point(size = 3, col='black')+
  ylab('GFAP coverage (QUINT)')+
  xlab('GFAP coverage (Fiji)')+
  theme_minimal() +
  themes +
  theme(legend.position = "none")

ggMarginal(regr, groupColour = TRUE, groupFill = T)

corrcoverage <- cor.test(coverage_nonPCs$GFAP_coverage, coverage_nonPCs$GFAP_Load, method = 'spearman')

kable(data.frame('Correlation' = c('Fiji-QUINT GFAP coverage'),
                 'Rho' = round(corrcoverage$estimate, 3),
                 'p_value' = round(corrcoverage$p.value, 4)))
```

```{r Fiji-QUINT_IBA correlations, warning = F, message = F}

#--------------IBA------------------------
regr <-  ggplot(coverage_nonPCs,aes(x=IBA_coverage,y=IBA_Load, Group=factor))+
  stat_smooth(method="lm", col='black')+
  geom_point(size = 3, col='black')+
  ylab('IBA coverage (QUINT)')+
  xlab('IBA coverage (Fiji)')+
  theme_minimal() +
  themes +
  theme(legend.position = "none")

ggMarginal(regr, groupColour = TRUE, groupFill = T)

corrcoverage <- cor.test(coverage_nonPCs$IBA_coverage, coverage_nonPCs$IBA_Load, method = 'spearman')

kable(data.frame('Correlation' = c('Fiji-QUINT IBA coverage'),
                 'Rho' = round(corrcoverage$estimate, 3),
                 'p_value' = round(corrcoverage$p.value, 4)))
```


# Inflammation signal coverage by slice - QUINT

## Coverage models

```{r coverage_QUINT, warning = F, message = F, results='hide'}
# GFAP
mod_GFAP_cov <- lmer(GFAP_Load~Group + (1|ID_easy),
                     data=coverage_nonPCs,
                     na.action=na.exclude)
summod_GFAP_cov <- summary(mod_GFAP_cov)

coverage_table[1:3, 'Response'] <- rep('GFAP coverage', 3)
coverage_table[1:3, 'Effect'] <- c('Control (intercept)', 'Window', 'Window+CORT')
coverage_table[1:3, 'Coefficient'] <- round(summod_GFAP_cov[["coefficients"]][1:3,1], 2)
coverage_table[1:3, 'Standard_error'] <- round(summod_GFAP_cov[["coefficients"]][1:3,2], 2)
coverage_table[1:3, 'T_value'] <- round(summod_GFAP_cov[["coefficients"]][1:3,4], 3)
coverage_table[1:3, 'p_value'] <- round(summod_GFAP_cov[["coefficients"]][1:3, 5], 4)

fittedplot(coverage_nonPCs, mod_GFAP_cov)

# IBA
mod_IBA_cov <- lmer(IBA_Load~Group + (1|ID_easy),
                    data=coverage_nonPCs,
                    na.action=na.exclude)
summod_IBA_cov <- summary(mod_IBA_cov)

coverage_table[4:6, 'Response'] <- rep('IBA coverage', 3)
coverage_table[4:6, 'Effect'] <- c('Control (intercept)', 'Window', 'Window+CORT')
coverage_table[4:6, 'Coefficient'] <- round(summod_IBA_cov[["coefficients"]][1:3,1], 2)
coverage_table[4:6, 'Standard_error'] <- round(summod_IBA_cov[["coefficients"]][1:3,2], 2)
coverage_table[4:6, 'T_value'] <- round(summod_IBA_cov[["coefficients"]][1:3,4], 3)
coverage_table[4:6, 'p_value'] <- round(summod_IBA_cov[["coefficients"]][1:3, 5], 4)

fittedplot(coverage_nonPCs, mod_IBA_cov)
```
```{r coverage_model_kable_QUINT, warning = F, message = F}
kable(coverage_table)
```

## Coverage contrasts

```{r coverage_contrasts_QUINT, warning = F, message = F}
#GFAP
cont_GFAP_cover <- summary(glht(mod_GFAP_cov, linfct=mcp(Group="Tukey")))
kable(data.frame(Comparisons = c("Control-Window", "Control-Window+CORT", "Window-Window+CORT"),
                 Coefficient = round(cont_GFAP_cover[["test"]][["coefficients"]], 2),
                 Standard_error = round(cont_GFAP_cover[["test"]][["sigma"]], 2),
                 T_value = round(cont_GFAP_cover[["test"]][["tstat"]], 3),
                 p_value = round(cont_GFAP_cover[["test"]][["pvalues"]],4)))

# Little-prince plot with bregmas pooled - GFAP
prince(coverage_nonPCs, coverage_nonPCs$GFAP_Load, 'GFAP coverage')+
  ylim(0,6.25)

# IBA
cont_IBA_cover <- summary(glht(mod_IBA_cov, linfct=mcp(Group="Tukey")))
kable(data.frame(Comparisons = c("Control-Window", "Control-Window+CORT", "Window-Window+CORT"),
                 Coefficient = round(cont_IBA_cover[["test"]][["coefficients"]], 2),
                 Standard_error = round(cont_IBA_cover[["test"]][["sigma"]], 2),
                 T_value = round(cont_IBA_cover[["test"]][["tstat"]], 3),
                 p_value = round(cont_IBA_cover[["test"]][["pvalues"]],4)))

# Little-prince plot with bregmas pooled - IBA
prince(coverage_nonPCs, coverage_nonPCs$IBA_Load, 'IBA coverage')+
  ylim(0,1.75)
```

```{r Faceted_princes_QUINT, warning = F, message = F, fig.width=16, fig.height=6}
# Little-prince plot with bregma faceting - GFAP
box(coverage_nonPCs, coverage_nonPCs$GFAP_Load, 'GFAP coverage') +
  facet_wrap(~Bregma, dir="v",ncol=4, scales = "free_y")+
  ylim(0,6.25)

# Little-prince plot with bregma faceting - IBA
box(coverage_nonPCs, coverage_nonPCs$IBA_Load, 'IBA coverage') +
  facet_wrap(~Bregma, dir="v",ncol=4, scales = "free_y")+
  ylim(0,1.75)
```

# Inflammation signal coverage for regions - QUINT

## Custom regions analysis

```{r Custom_regions, warning = F, message = F, fig.width=11}
# Little-prince plot with region faceting - GFAP
GFAP_Customregions_Allslices <- GFAP_Customregions_Allslices[GFAP_Customregions_Allslices$NA. %in% c("Window+CORTex","Fibretracts","Hippocampus","Olfactory","Hypothalamus","Striatum_Pallidum","Thalamus","Ventricular_System"),]
prince(GFAP_Customregions_Allslices, GFAP_Customregions_Allslices$Load, 'GFAP coverage') +
  facet_wrap(~NA., dir="v",ncol=4)+
  scale_color_manual(values=c('#648FFF', '#785EF0', '#DC267F')) +
  scale_fill_manual(values=c('#648FFF', '#785EF0', '#DC267F'))+
  ylim(0,12)


# Little-prince plot with region faceting - IBA
IBA_Customregions_Allslices <- IBA_Customregions_Allslices[IBA_Customregions_Allslices$NA. %in% c("Window+CORTex","Fibretracts","Hippocampus","Olfactory","Hypothalamus","Striatum_Pallidum","Thalamus","Ventricular_System"),]
prince(IBA_Customregions_Allslices, IBA_Customregions_Allslices$Load, 'IBA coverage') +
  facet_wrap(~NA., dir="v",ncol=4)+
  scale_color_manual(values=c('#648FFF', '#785EF0', '#DC267F')) +
  scale_fill_manual(values=c('#648FFF', '#785EF0', '#DC267F'))+
  ylim(0,2)
```

## Random forest analysis - GFAP

```{r random_forest, warning = F, message = F}
# Creation of wide data frame type for exclusion of zero-area brain regions
subsetted <- GFAP_RefAtlasRegions_Allslices[GFAP_RefAtlasRegions_Allslices$Group %in% c('Window', 'Window+CORT'),]
filter <- subsetted[, c(1,4,5)]

filter <- reshape(filter,idvar="ID_easy",
                     timevar = "Region.name",
                     direction="wide")
filter$Group <- coverage$Group[1:6]

# If you want to include the variables that have non-zero values for ALL the animals
nullvekt <- rep(0, nrow(filter))
jo_oszlopok_szamai <- rep(F, ncol(filter))

for(x in 1:ncol(filter)) {
  if(sum(filter[, x] == nullvekt) == 0) {
    jo_oszlopok_szamai[x] <- T
  }
}

filter_mutilated <- filter[jo_oszlopok_szamai]
column_names <- colnames(filter_mutilated)
clean_column_names <- sub("^Region.pixels\\.", "", column_names)

# Now create the actual data.frame containing the Load*100 values for non-zero-area regions
foresthez <- subsetted[subsetted$Region.name %in% clean_column_names, c(1,4,12)]
foresthez <- reshape(foresthez,idvar="ID_easy",
                     timevar = "Region.name",
                     direction="wide")
foresthez$Group <- coverage$Group[1:6]

# # If you want to include the variables that have non-zero values for MORE THAN ONE animal
# # Check for columns with non-zero values
# non_zero_columns <- apply(foresthez[, -1], 2, function(x) sum(x != 0) > 0)
# 
# # Subset the data frame to keep only columns with non-zero values
# foresthez_mutilated <- foresthez[, c(TRUE, non_zero_columns)]

# creating a vector with nicer, shorter variable names
vektor <- c()
for(x in 1:(ncol(foresthez)-2)) {
  vektor[x] <- paste('a', x, sep = '')
}

# dataframe with modified variable names
foresthez_mutilated_simple <- foresthez
colnames(foresthez_mutilated_simple) <- c('Animal', vektor, 'Group')

# Ensuring there are no empty classes
foresthez_mutilated_simple$Group <- factor(foresthez_mutilated_simple$Group, levels = c('Window', 'Window+CORT'))

# helping printing out the random forest arguments that you can paste directly to the function
row <- colnames(foresthez_mutilated_simple)
current <- c()

for(x in 1:(ncol(foresthez)-1)) {
  current[x] <- paste(row[x], "+")
}

paste(current, collapse = ' ')

# Doing the random forest
set.seed(20240418)
forest <- randomForest(Group ~ a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20 + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30 + a31 + a32 + a33 + a34 + a35 + a36 + a37 + a38 + a39 + a40 + a41 + a42 + a43 + a44 + a45 + a46 + a47 + a48 + a49 + a50 + a51 + a52 + a53 + a54 + a55 + a56 + a57 + a58 + a59 + a60 + a61 + a62 + a63 + a64 + a65 + a66 + a67 + a68 + a69 + a70 + a71 + a72 + a73 + a74 + a75 + a76 + a77 + a78 + a79 + a80 + a81 + a82 + a83 + a84 + a85 + a86 + a87 + a88 + a89 + a90 + a91 + a92 + a93 + a94, 
                       data=foresthez_mutilated_simple, 
                       localImp = T, 
                       s.e. = 1,
                       ntree = 10000)

#random forest impoartance
importance_frame <- measure_importance(forest)

# Adding needed variables in the importance frame
importance_frame$color <- factor(ifelse(importance_frame$p_value <= 0.05, 
                                        "darkviolet",
                                        "turquoise4"))

# Inputting proper brain area names in the importance frame
column_names <- colnames(foresthez)
clean_column_names <- sub("^Load\\.", "", column_names)
clean_column_names <- clean_column_names[-c(1,74)]
importance_frame$label <- clean_column_names[as.numeric(sub("^a", "", importance_frame$variable))]

# Plotting these
ggplot(importance_frame,aes(y=no_of_nodes,x=gini_decrease, color=color)) +
  geom_point(aes(size = importance_frame$no_of_trees)) +
  ylab('Number of nodes')+
  xlab("Gini decrease") +
  theme_minimal() +
  geom_label_repel(label= importance_frame$label,
                   max.overlaps = 7,
                   force = 1600) +
  theme(axis.title.y = element_text(size = rel(1.5),
                                    angle = 90,
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(1.5),
                                    angle = 0,
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(1.2), face = "bold"),
        legend.text = element_text(size = rel(1.2), angle = 0),
        axis.text  = element_text(size = rel(1.5), angle = 0)) +
  scale_size(range = c(.1, 5), name="Number of trees") +
  xlim(min(importance_frame$gini_decrease)*0.7,
       max(importance_frame$gini_decrease)*1.2) +
  ylim(min(importance_frame$no_of_nodes)*0.9,
       max(importance_frame$no_of_nodes)*1.5)+
  scale_color_manual(values=levels(importance_frame$color), name = "Significance", labels = c("p < 0,05", "p > 0,05")) +
  geom_point(aes(size = importance_frame$no_of_trees)) +
  guides(colour = guide_legend(override.aes = list(size = 3)))
```


```{r importance_plotting, warning = F, message = F, fig.width=16, fig.height=20}
ggplot(importance_frame,aes(x=gini_decrease, y=  reorder(label, gini_decrease), fill = color)) +
  geom_bar(stat="identity") +
  xlab("Decrease in Gini index (classification accuracy)")+
  ylab("Brain areas") +
  theme_minimal()+
  theme(axis.title.y = element_text(size = rel(2.5), 
                                    angle = 90, 
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(2.5), 
                                    angle = 0, 
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(2.2), face = "bold"),
        legend.text = element_text(size = rel(2.2), angle = 0),
        axis.text  = element_text(size = rel(1.5), angle = 0)) +
  scale_fill_manual(values=levels(importance_frame$color), name = "Significance", labels = c("p < 0,05", "p > 0,05"))

kable(importance_frame[,c(10, 3:8)])
```


```{r boxplotting_significant_ones, warning = F, message = F, fig.width=16, fig.height=16}
significants <- subsetted[subsetted$Region.name %in% importance_frame[importance_frame$color == 'darkviolet','label'],]

box_signo(significants, significants$Load, 'GFAP coverage') +
  facet_wrap(~Region.name, dir="v",ncol=3, scales = "free_y")+
  scale_color_manual(values=c('#785EF0', '#DC267F')) +
  scale_fill_manual(values=c('#785EF0', '#DC267F'))+
  ylim(0,12.5)+
  theme(axis.title.y = element_text(size = rel(2), 
                                    angle = 90, 
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(2), 
                                    angle = 0, 
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(2), face = "bold"),
        legend.text = element_text(size = rel(2), angle = 0),
        axis.text  = element_text(size = rel(1.0), angle = 0))
```

```{r T_testing, warning = F, message = F}
significant_area_vector <- importance_frame[importance_frame$color == 'darkviolet','label']
load_table <- data.frame("Brain_area" = NA,
                         "Estimate_Window" = NA,
                         "Estimate_Window+CORT" =NA,
                         "Standard_error" =NA, 
                         "T_value" = NA, 
                         "p_value" =NA)

for(area in 1:length(significant_area_vector)) {
  selected <- significants[significants$Region.name == significant_area_vector[area],]
  
  Window_data <- subset(selected, Group == "Window")$Load
  Window_CORT_data <- subset(selected, Group == "Window+CORT")$Load
  t_test_Window_CORT <- t.test(Window_data, Window_CORT_data)

  load_table[area, 'Brain_area'] <- significant_area_vector[area]
  load_table[area, 'Estimate_Window'] <- round(t_test_Window_CORT$estimate[1], 2)
  load_table[area, 3] <- round(t_test_Window_CORT$estimate[2], 2)
  load_table[area, 'Standard_error'] <- round(t_test_Window_CORT$stderr, 2)
  load_table[area, 'T_value'] <- round(t_test_Window_CORT$statistic, 3)
  load_table[area, 'p_value'] <- round(t_test_Window_CORT$p.value, 4)
}

load_table$p_value_adjusted <- p.adjust(load_table$p_value, method = "fdr")

kable(load_table)
```

## Random forest analysis - IBA

```{r random_forest_iba, warning = F, message = F}
# Creation of wide data frame type for exclusion of zero-area brain regions
subsetted <- IBA_RefAtlasRegions_Allslices[IBA_RefAtlasRegions_Allslices$Group %in% c('Window', 'Window+CORT'), ]
filter <- subsetted[,c(1,4,5)]

filter <- reshape(filter,idvar="ID_easy",
                     timevar = "Region.name",
                     direction="wide")
filter$Group <- coverage$Group[1:6]

# If you want to include the variables that have non-zero values for ALL the animals
nullvekt <- rep(0, nrow(filter))
jo_oszlopok_szamai <- rep(F, ncol(filter))

for(x in 1:ncol(filter)) {
  if(sum(filter[, x] == nullvekt) == 0) {
    jo_oszlopok_szamai[x] <- T
  }
}

filter_mutilated <- filter[jo_oszlopok_szamai]
column_names <- colnames(filter_mutilated)
clean_column_names <- sub("^Region.pixels\\.", "", column_names)

# Now create the actual data.frame containing the Load*100 values for non-zero-area regions
foresthez <- subsetted[subsetted$Region.name %in% clean_column_names, c(1,4,12)]
foresthez <- reshape(foresthez,idvar="ID_easy",
                     timevar = "Region.name",
                     direction="wide")
foresthez$Group <- coverage$Group[1:6]


# # If you want to include the variables that have non-zero values for MORE THAN ONE animal
# # Check for columns with non-zero values
# non_zero_columns <- apply(foresthez[, -1], 2, function(x) sum(x != 0) > 0)
# 
# # Subset the data frame to keep only columns with non-zero values
# foresthez_mutilated <- foresthez[, c(TRUE, non_zero_columns)]

# creating a vector with nicer, shorter variable names
vektor <- c()
for(x in 1:(ncol(foresthez)-2)) {
  vektor[x] <- paste('a', x, sep = '')
}

# dataframe with modified variable names
foresthez_mutilated_simple <- foresthez
colnames(foresthez_mutilated_simple) <- c('Animal', vektor, 'Group')

# Ensuring there are no empty classes
foresthez_mutilated_simple$Group <- factor(foresthez_mutilated_simple$Group, levels = c('Window', 'Window+CORT'))

# helping printing out the random forest arguments that you can paste directly to the function
row <- colnames(foresthez_mutilated_simple)
current <- c()

for(x in 1:(ncol(foresthez)-1)) {
  current[x] <- paste(row[x], "+")
}

paste(current, collapse = ' ')

# Doing the random forest
set.seed(20240418)
forest <- randomForest(Group ~ a1 + a2 + a3 + a4 + a5 + a6 + a7 + a8 + a9 + a10 + a11 + a12 + a13 + a14 + a15 + a16 + a17 + a18 + a19 + a20 + a21 + a22 + a23 + a24 + a25 + a26 + a27 + a28 + a29 + a30 + a31 + a32 + a33 + a34 + a35 + a36 + a37 + a38 + a39 + a40 + a41 + a42 + a43 + a44 + a45 + a46 + a47 + a48 + a49 + a50 + a51 + a52 + a53 + a54 + a55 + a56 + a57 + a58 + a59 + a60 + a61 + a62 + a63 + a64 + a65 + a66 + a67 + a68 + a69 + a70 + a71 + a72 + a73 + a74 + a75 + a76 + a77 + a78 + a79 + a80 + a81 + a82 + a83 + a84 + a85 + a86 + a87 + a88 + a89 + a90 + a91 + a92 + a93 + a94, 
                       data=foresthez_mutilated_simple, 
                       localImp = T, 
                       s.e. = 1,
                       ntree = 10000)

#random forest impoartance
importance_frame <- measure_importance(forest)

# Adding needed variables in the importance frame
importance_frame$color <- factor(ifelse(importance_frame$p_value <= 0.05, 
                                        "darkviolet",
                                        "turquoise4"))

# Inputting proper brain area names in the importance frame
column_names <- colnames(foresthez)
clean_column_names <- sub("^Load\\.", "", column_names)
clean_column_names <- clean_column_names[-c(1,ncol(clean_column_names))]
importance_frame$label <- clean_column_names[as.numeric(sub("^a", "", importance_frame$variable))]

# Plotting these
ggplot(importance_frame,aes(y=no_of_nodes,x=gini_decrease, color=color)) +
  geom_point(aes(size = importance_frame$no_of_trees)) +
  ylab('Number of nodes')+
  xlab("Gini decrease") +
  theme_minimal() +
  geom_label_repel(label= importance_frame$label,
                   max.overlaps = 7,
                   force = 1600) +
  theme(axis.title.y = element_text(size = rel(1.5),
                                    angle = 90,
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(1.5),
                                    angle = 0,
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(1.2), face = "bold"),
        legend.text = element_text(size = rel(1.2), angle = 0),
        axis.text  = element_text(size = rel(1.5), angle = 0)) +
  scale_size(range = c(.1, 5), name="Number of trees") +
  xlim(min(importance_frame$gini_decrease)*0.7,
       max(importance_frame$gini_decrease)*1.2) +
  ylim(min(importance_frame$no_of_nodes)*0.9,
       max(importance_frame$no_of_nodes)*1.5)+
  scale_color_manual(values=levels(importance_frame$color), name = "Significance", labels = c("p < 0,05", "p > 0,05")) +
  geom_point(aes(size = importance_frame$no_of_trees)) +
  guides(colour = guide_legend(override.aes = list(size = 3)))
```


```{r importance_plotting_iba, warning = F, message = F, fig.width=16, fig.height=20}
ggplot(importance_frame,aes(x=gini_decrease, y=  reorder(label, gini_decrease), fill = color)) +
  geom_bar(stat="identity") +
  xlab("Decrease in Gini index (classification accuracy)")+
  ylab("Brain areas") +
  theme_minimal()+
  theme(axis.title.y = element_text(size = rel(2.5), 
                                    angle = 90, 
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(2.5), 
                                    angle = 0, 
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(2.2), face = "bold"),
        legend.text = element_text(size = rel(2.2), angle = 0),
        axis.text  = element_text(size = rel(1.5), angle = 0)) +
  scale_fill_manual(values=levels(importance_frame$color), name = "Significance", labels = c("p < 0,05", "p > 0,05"))

kable(importance_frame[,c(10, 3:8)])

```

```{r boxplotting_significant_ones_iba, warning = F, message = F, fig.width=16, fig.height=16}
significants <- subsetted[subsetted$Region.name %in% importance_frame[importance_frame$color == 'darkviolet','label'],]

box_signo(significants, significants$Load, 'IBA coverage') +
  facet_wrap(~Region.name, dir="v",ncol=3, scales = "free_y")+
  scale_color_manual(values=c('#785EF0', '#DC267F')) +
  scale_fill_manual(values=c('#785EF0', '#DC267F'))+
#  ylim(0,12.5)+
  theme(axis.title.y = element_text(size = rel(2), 
                                    angle = 90, 
                                    margin = ggplot2::margin(t = 0, r = 20, b = 0, l = 0)),
        axis.title.x = element_text(size = rel(2), 
                                    angle = 0, 
                                    margin = ggplot2::margin(t = 10, r = 0, b = 0, l = 0)),
        legend.title = element_text(size = rel(2), face = "bold"),
        legend.text = element_text(size = rel(2), angle = 0),
        axis.text  = element_text(size = rel(1.0), angle = 0))+
  ylim(0,2.5)
```

```{r T_testing_iba, warning = F, message = F}
significant_area_vector <- importance_frame[importance_frame$color == 'darkviolet','label']
load_table <- data.frame("Brain_area" = NA,
                         "Estimate_Window" = NA,
                         "Estimate_Window+CORT" =NA,
                         "Standard_error" =NA, 
                         "T_value" = NA, 
                         "p_value" =NA)

for(area in 1:length(significant_area_vector)) {
  selected <- significants[significants$Region.name == significant_area_vector[area],]
  
  Window_data <- subset(selected, Group == "Window")$Load
  Window_CORT_data <- subset(selected, Group == "Window+CORT")$Load
  t_test_Window_CORT <- t.test(Window_data, Window_CORT_data)

  load_table[area, 'Brain_area'] <- significant_area_vector[area]
  load_table[area, 'Estimate_Window'] <- round(t_test_Window_CORT$estimate[1], 2)
  load_table[area, 3] <- round(t_test_Window_CORT$estimate[2], 2)
  load_table[area, 'Standard_error'] <- round(t_test_Window_CORT$stderr, 2)
  load_table[area, 'T_value'] <- round(t_test_Window_CORT$statistic, 3)
  load_table[area, 'p_value'] <- round(t_test_Window_CORT$p.value, 4)
}

load_table$p_value_adjusted <- p.adjust(load_table$p_value, method = "fdr")

kable(load_table)
```

```{r exporting_czi_trials, include = F}
# install.packages("readCzi")
# 
# # Load the required packages
# library(readCzi)
# library(EBImage)  # For image processing
# 
# # Set input and output paths
# input_dir <- "E:/Aron"
# output_dir <- "D:/Microscopy/ExportingWithR"
# 
# # List of animals (IDs)
# animal_ids <- 1:10
# 
# # Loop through each animal ID
# for (id in animal_ids) {
#   # Loop through each slice (assuming 4 slices per animal)
#   for (slice in 1:4) {
#     # Construct the CZI file name
#     czi_filename <- paste0("GFAP-IBA-NEUN_10x_ID", id, "_Slice", slice)
#     czi_filepath <- file.path(input_dir, paste0(czi_filename, ".czi"))
#     
#     # Read CZI file
#     image_data <- readCzi(input_file = czi_filepath)
#     
#     # Normalize pixel values (adjust brightness and contrast)
#     normalized_image <- normalize(image_data)
#     
#     # Save as JPEG
#     jpeg_filename <- paste0(czi_filename, ".jpeg")
#     jpeg_filepath <- file.path(output_dir, jpeg_filename)
#     writeJPEG(normalized_image, target = jpeg_filepath, quality = 90)
#   }
# }
# 
# # Done! Exported JPEG images are saved in the specified output directory.
# 
# 
# 
# #---------------------------------------------------------------------
# 
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# 
# BiocManager::install("EBImage")
# install.packages("cziR")  # If this package doesn't work, you may try using another like `CZIReader`
# 
# 
# library(EBImage)
# library(cziR)
# library(magrittr)
# 
# # Set paths
# input_path <- "E:/Aron"
# output_path <- "D:/Microscopy/ExportingWithR"
# 
# # Check if output directory exists; if not, create it
# if (!dir.exists(output_path)) {
#   dir.create(output_path, recursive = TRUE)
# }
# 
# # List of animal IDs and their slices
# animals <- 1:10
# slices <- 1:4
# exceptions <- list("4" = 1:2)  # ID 4 has only two slices
# 
# # Function to process and save each image
# process_and_save_image <- function(id, slice) {
#   filename_czi <- sprintf("GFAP-IBA-NEUN_10x_ID%d_Slice%d.czi", id, slice)
#   filename_jpeg <- sprintf("GFAP-IBA-NEUN_10x_ID%d_Slice%d.jpg", id, slice)
#   
#   # Full path for input and output
#   full_path_czi <- file.path(input_path, filename_czi)
#   full_path_jpeg <- file.path(output_path, filename_jpeg)
#   
#   # Load image
#   image <- read.czi(full_path_czi)  # or use load.czi() based on your package
#   
#   # Adjust brightness and contrast, might need adjustment based on actual image data
#   image_adjusted <- image %>% 
#     normalize() %>% 
#     adjust_brightness(contrast = 1.5, bias = 0.1) %>%
#     normalize()
#   
#   # Save the image as JPEG
#   writeImage(image_adjusted, full_path_jpeg, quality = 90)
# }
# 
# # Loop through each animal and each slice
# for (id in animals) {
#   current_slices <- slices
#   if (as.character(id) %in% names(exceptions)) {
#     current_slices <- exceptions[[as.character(id)]]
#   }
#   for (slice in current_slices) {
#     process_and_save_image(id, slice)
#   }
# }
# 
# 
# 
# #---------------------------------------------------------------------
# 
# library(EBImage)
# 
# # Set paths
# input_path <- "E:/Aron"
# output_path <- "D:/Microscopy/ExportingWithR"
# 
# # Check if output directory exists; if not, create it
# if (!dir.exists(output_path)) {
#   dir.create(output_path, recursive = TRUE)
# }
# 
# # List of animal IDs and their slices
# animals <- 1:10
# slices <- 1:4
# exceptions <- list("4" = 1:2)  # ID 4 has only two slices
# 
# # Function to process and save each image
# process_and_save_image <- function(id, slice) {
#   filename_czi <- sprintf("GFAP-IBA-NEUN_10x_ID%d_Slice%d.czi", id, slice)
#   filename_jpeg <- sprintf("GFAP-IBA-NEUN_10x_ID%d_Slice%d.jpg", id, slice)
#   
#   # Full path for input and output
#   full_path_czi <- file.path(input_path, filename_czi)
#   full_path_jpeg <- file.path(output_path, filename_jpeg)
#   
#   # Load image using readImage from EBImage, which uses BioFormats
#   image <- readImage(full_path_czi)
#   
#   # Adjust brightness and contrast, might need adjustment based on actual image data
#   image_adjusted <- image %>%
#     normalize() %>%
#     adjust_brightness(contrast = 1.5, bias = 0.1) %>%
#     normalize()
#   
#   # Save the image as JPEG
#   writeImage(image_adjusted, full_path_jpeg, quality = 90)
# }
# 
# # Loop through each animal and each slice
# for (id in animals) {
#   current_slices <- slices
#   if (as.character(id) %in% names(exceptions)) {
#     current_slices <- exceptions[[as.character(id)]]
#   }
#   for (slice in current_slices) {
#     process_and_save_image(id, slice)
#   }
# }
# 
# 
# 
# #---------------------------------------------------------------------
# # ... [previous code]
# 
# for (id in animal_ids) {
#   for (slice in 1:4) {
#     # Skip the loop for ID4 if slice is greater than 2
#     if (id == 4 && slice > 2) next
#     
#     czi_filename <- paste0("GFAP-IBA-NEUN_10x_ID", id, "_Slice", slice)
#     czi_filepath <- file.path(input_dir, paste0(czi_filename, ".czi"))
#     
#     # Check if the file exists before attempting to read
#     if (file.exists(czi_filepath)) {
#       image_data <- readCzi(input_file = czi_filepath)
#       
#       # Debugging: Print the length of detector_information
#       print(length(image_data$detector_information))
#       
#       # Normalize pixel values (adjust brightness and contrast)
#       normalized_image <- normalize(image_data)
#       
#       # Save as JPEG
#       jpeg_filename <- paste0(czi_filename, ".jpeg")
#       jpeg_filepath <- file.path(output_dir, jpeg_filename)
#       writeJPEG(normalized_image, target = jpeg_filepath, quality = 90)
#     } else {
#       cat("File does not exist:", czi_filepath, "\n")
#     }
#   }
# }
# 
# # ... [rest of the code]
# 

```


